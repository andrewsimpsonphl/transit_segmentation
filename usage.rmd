---
title: "Usage Information"
author: "Andrew Simpson"
date: "03-30-20"
output: html_document
keep_md: TRUE
---

```{r setup, include=FALSE}
library(tidyverse) ; library(httr) ; library(jsonlite) ; library(geojsonsf) ; library(lubridate)
library(sf)  ;  library(leaflet)  ;  library(htmltools) ; library(knitr)  ; library(feather)
library(reactable)

source("code/segmentation_code.R")

```

## Pull Data from ARCGIS Online

```{r pull_data, include=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
# First Step is to read in the stops that have their corresponding Link numbers precalculated. (This data was produce by the DVRPC RTSP project in 2019)
stops <- read_stops()

# Running `pull_arcgis_dat()` will download the most recent shapefiles through an ArcGIS Online API call and assign `FINAL_ID` to each segment.
gis_dat <- pull_arcgis_dat()

head(gis_dat) %>% select(FINAL_ID, fromto)

```

## Load data onto segments

Key thing to know:
Links are from/to links taken from model. Segments are coded and joined links that are the transit corridor. 

Running load_coded_links() will assign stop_id to each link. 
Running nest_segments will build a nested dataframe with an entry for each segment, based on its unique FINAL_ID, and then create a list of stops along each of the segments. 
```{r load_data, include=TRUE, echo=TRUE, warning=FALSE}

nested_data <- gis_dat %>%
  load_coded_links(stops) %>%  
  nest_segments(stops)

reactable(nested_data)

```

## Compile APC Data to the Segment Level

```{r compile_data, include=TRUE, echo=TRUE, warning=FALSE}

segments_with_apc_dat <- nested_data %>% 
  filter(between(as.numeric(FINAL_ID), FINAL_ID_LIST[1], FINAL_ID_LIST[100])) %>%
  compile_apc_dat() 

reactable(segments_with_apc_dat)

```